# ðŸš€ Auto-Release PRIVÃ‰ UNIQUEMENT
name: Auto Release

on:
  push:
    tags:
      - 'v*.*.*'
      - 'test-*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version Ã  releaser (ex: v1.0.0)'
        required: true
        default: 'v1.0.0'

permissions:
  contents: write
  actions: read

env:
  APP_NAME: "ZymoSync"
  PYTHON_VERSION: "3.9"
  # ID du dossier Google Drive cible
  GDRIVE_FOLDER_ID: "1EMQfuyMNHNc3170KXiSbyalx9HbQX5SN"

jobs:
  private-build:
    name: ðŸ”¨ Build PrivÃ© avec Credentials
    runs-on: windows-latest

    steps:
    - name: ðŸ“¥ Checkout du code
      uses: actions/checkout@v4

    - name: ðŸ·ï¸ Extraire la version
      id: version
      shell: bash
      run: |
        if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          VERSION="${{ github.event.inputs.version }}"
        else
          VERSION=${GITHUB_REF#refs/tags/}
        fi

        echo "version=$VERSION" >> $GITHUB_OUTPUT

        CLEAN_VERSION=${VERSION#v}
        echo "clean_version=$CLEAN_VERSION" >> $GITHUB_OUTPUT

        echo "ðŸ“¦ Version: $VERSION"

    - name: ðŸ Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: ðŸ“¦ Installer les dÃ©pendances
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pyinstaller

    # ===== CREDENTIALS PRIVÃ‰S UNIQUEMENT =====
    - name: ðŸ”‘ Setup Credentials PrivÃ©s
      shell: bash
      run: |
        echo "ðŸ” Configuration des credentials privÃ©s..."

        # CrÃ©er le dossier resources
        mkdir -p resources

        # VÃ©rifier que le secret existe
        if [[ -z "${{ secrets.GOOGLE_CREDENTIALS_JSON }}" ]]; then
          echo "âŒ ERREUR: Secret GOOGLE_CREDENTIALS_JSON manquant!"
          echo "ðŸ“ Pour corriger:"
          echo "   1. Allez dans Settings > Secrets and variables > Actions"
          echo "   2. Cliquez 'New repository secret'"
          echo "   3. Nom: GOOGLE_CREDENTIALS_JSON"
          echo "   4. Valeur: Collez le contenu de votre credentials.json"
          exit 1
        fi

        echo "âœ… Secret trouvÃ©, crÃ©ation du fichier credentials..."

        # Ã‰crire le JSON depuis les secrets (mÃ©thode sÃ©curisÃ©e)
        echo '${{ secrets.GOOGLE_CREDENTIALS_JSON }}' > resources/credentials.json

        # VÃ©rifier que le JSON est valide
        if python -m json.tool resources/credentials.json > /dev/null 2>&1; then
          echo "âœ… Credentials JSON valide"
        else
          echo "âŒ ERREUR: JSON credentials invalide dans le secret"
          echo "ðŸ” VÃ©rifiez que le secret contient un JSON valide"
          exit 1
        fi

        # VÃ©rifier la prÃ©sence des clÃ©s importantes
        if grep -q "client_id" resources/credentials.json && grep -q "client_secret" resources/credentials.json; then
          echo "âœ… Credentials semblent complets (client_id et client_secret trouvÃ©s)"
        else
          echo "âš ï¸ WARNING: client_id ou client_secret non trouvÃ©s dans les credentials"
        fi

        echo "âœ… Credentials privÃ©s configurÃ©s avec succÃ¨s"

    - name: ðŸ§¹ Nettoyer les anciens builds
      shell: pwsh
      run: |
        Write-Host "ðŸ§¹ Nettoyage..."
        if (Test-Path "build") { Remove-Item -Recurse -Force "build" }
        if (Test-Path "dist") { Remove-Item -Recurse -Force "dist" }
        Get-ChildItem -Filter "*.spec" | Remove-Item -Force
        Write-Host "âœ… Nettoyage terminÃ©"

    - name: ðŸ”¨ Build avec PyInstaller
      shell: pwsh
      run: |
        Write-Host "ðŸš€ Build privÃ© en cours..."

        pyinstaller --onedir --windowed `
          --icon=resources/icon.ico `
          --hidden-import=googleapiclient.discovery `
          --hidden-import=googleapiclient.http `
          --hidden-import=google.auth.transport.requests `
          --hidden-import=google.oauth2.credentials `
          --hidden-import=charset_normalizer.md__mypyc `
          --hidden-import=sip `
          --collect-all PyQt5 `
          --add-data "resources;resources" `
          --name ${{ env.APP_NAME }} `
          main.py

        Write-Host "âœ… Build terminÃ© avec succÃ¨s"

    - name: âœ… VÃ©rifier le build
      shell: pwsh
      run: |
        $exePath = "dist\${{ env.APP_NAME }}\${{ env.APP_NAME }}.exe"
        $credPath = "dist\${{ env.APP_NAME }}\resources\credentials.json"

        if (Test-Path $exePath) {
          Write-Host "âœ… ExÃ©cutable crÃ©Ã©: $exePath"
          $size = (Get-Item $exePath).Length / 1MB
          Write-Host "ðŸ“ Taille exe: $([math]::Round($size, 1)) MB"
        } else {
          Write-Host "âŒ ExÃ©cutable non trouvÃ©!"
          Write-Host "ðŸ“ Contenu de dist:"
          Get-ChildItem -Path "dist" -Recurse
          exit 1
        }

        if (Test-Path $credPath) {
          Write-Host "âœ… Credentials inclus dans le build"
        } else {
          Write-Host "âŒ WARNING: credentials.json non trouvÃ© dans le build"
          Write-Host "ðŸ” Recherche dans resources:"
          Get-ChildItem -Path "dist\${{ env.APP_NAME }}" -Recurse -Filter "credentials.json"
        }

        # Afficher la structure du build
        Write-Host "ðŸ“ Structure du build final:"
        Get-ChildItem -Path "dist\${{ env.APP_NAME }}" | Select-Object Name, Length | Format-Table

    - name: ðŸ“¦ CrÃ©er ZIP prÃªt Ã  utiliser
      shell: pwsh
      run: |
        $VERSION = "${{ steps.version.outputs.clean_version }}"
        $ZIP_NAME = "${{ env.APP_NAME }}-v$VERSION-Windows-READY"
        $ZIP_FILE = "$ZIP_NAME.zip"

        Write-Host "ðŸ“¦ CrÃ©ation du ZIP prÃªt Ã  utiliser..."

        # CrÃ©er un README pour le ZIP
        $readme = @"
            # ðŸš€ ${{ env.APP_NAME }} v$VERSION - PRÃŠT Ã€ UTILISER

            ## âœ… Installation ImmÃ©diate

            1. **Extraire** ce ZIP dans un dossier de votre choix
            2. **Lancer** ${{ env.APP_NAME }}.exe
            3. **Autoriser** l'accÃ¨s Google Drive au premier lancement
            4. **C'est tout !** L'application est prÃªte Ã  utiliser

            ## ðŸ”‘ Credentials Inclus

            Cette version inclut vos credentials Google Drive API personnels.
            Aucune configuration supplÃ©mentaire n'est nÃ©cessaire.

            ## ðŸ†˜ Support

            - Documentation: https://github.com/${{ github.repository }}
            - Issues: https://github.com/${{ github.repository }}/issues

            ---
            Build privÃ© gÃ©nÃ©rÃ© automatiquement le $(Get-Date -Format "yyyy-MM-dd HH:mm")
        "@

        $readme | Out-File -FilePath "dist\${{ env.APP_NAME }}\README.txt" -Encoding UTF8

        # CrÃ©er le ZIP
        Compress-Archive -Path "dist\${{ env.APP_NAME }}\*" -DestinationPath $ZIP_FILE -Force

        if (Test-Path $ZIP_FILE) {
          $zipSize = (Get-Item $ZIP_FILE).Length / 1MB
          Write-Host "âœ… ZIP crÃ©Ã©: $ZIP_FILE"
          Write-Host "ðŸ“ Taille ZIP: $([math]::Round($zipSize, 1)) MB"
        } else {
          Write-Host "âŒ Erreur: ZIP non crÃ©Ã©"
          exit 1
        }

        echo "ZIP_FILE=$ZIP_FILE" >> $env:GITHUB_ENV
        echo "ZIP_NAME=$ZIP_NAME" >> $env:GITHUB_ENV

    - name: ðŸ“ GÃ©nÃ©rer changelog
      id: changelog
      shell: bash
      run: |
        VERSION="${{ steps.version.outputs.version }}"

        # CrÃ©er le changelog dans un fichier temporaire pour Ã©viter les problÃ¨mes d'Ã©chappement
        cat > changelog.md << 'EOF'
        ## ðŸš€ ZymoSync $VERSION - Build PrivÃ©

        ðŸ“… **Date**: $(date '+%Y-%m-%d %H:%M:%S')
        ðŸ” **Type**: Build privÃ© avec credentials intÃ©grÃ©s

        ### âœ… PrÃªt Ã  Utiliser ImmÃ©diatement

        Cette version inclut vos credentials Google Drive API personnels.
        Aucune configuration supplÃ©mentaire n'est requise!

        ### ðŸš€ Installation Ultra-Simple

        1. **TÃ©lÃ©chargez** le ZIP ci-dessous
        2. **Extrayez** dans un dossier de votre choix
        3. **Double-cliquez** sur ZymoSync.exe
        4. **Autorisez** Google Drive au premier lancement
        5. **Enjoy!** ðŸŽ‰

        ### ðŸ“¦ DÃ©tails Techniques

        - **Plateforme**: Windows x64
        - **Python**: 3.9
        - **PyQt5**: Inclus
        - **Credentials**: IntÃ©grÃ©s (prÃªt Ã  utiliser)

        ### ðŸ”’ SÃ©curitÃ©

        Ce build privÃ© contient vos credentials personnels Google Drive.
        Ne partagez pas ce fichier avec d'autres personnes.

        ---

        ðŸ’¡ **Besoin d'aide?** Consultez le README.txt inclus dans le ZIP!
        EOF

        # Remplacer la variable VERSION dans le fichier
        sed -i "s/\$VERSION/$VERSION/g" changelog.md

        # Lire le contenu et l'encoder en base64 pour Ã©viter les problÃ¨mes d'Ã©chappement
        CHANGELOG_B64=$(base64 -w 0 changelog.md)
        echo "changelog_b64=$CHANGELOG_B64" >> $GITHUB_OUTPUT

    - name: ðŸŽ‰ CrÃ©er Release PrivÃ©e
      id: create_release
      uses: actions/github-script@v7
      with:
        script: |
          const { owner, repo } = context.repo;
          const tag = "${{ steps.version.outputs.version }}";
          const name = `ðŸ” ZymoSync ${tag} (PrivÃ©)`;

          // DÃ©coder le changelog depuis base64
          const changelogB64 = "${{ steps.changelog.outputs.changelog_b64 }}";
          const body = Buffer.from(changelogB64, 'base64').toString('utf8');

          console.log('ðŸŽ¯ CrÃ©ation de la release privÃ©e...');
          console.log('Tag:', tag);
          console.log('Nom:', name);

          try {
            const release = await github.rest.repos.createRelease({
              owner,
              repo,
              tag_name: tag,
              name: name,
              body: body,
              draft: false,
              prerelease: false
            });

            console.log('âœ… Release crÃ©Ã©e:', release.data.html_url);

            core.setOutput('release_id', release.data.id);
            core.setOutput('upload_url', release.data.upload_url);
            core.setOutput('html_url', release.data.html_url);

          } catch (error) {
            console.error('âŒ Erreur crÃ©ation release:', error);
            throw error;
          }

    - name: ðŸ“Ž Upload ZIP vers Release
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          const path = require('path');

          const zipFile = '${{ env.ZIP_FILE }}';
          const uploadUrl = '${{ steps.create_release.outputs.upload_url }}';

          console.log('ðŸ“Ž Upload du ZIP privÃ©:', zipFile);

          try {
            const data = fs.readFileSync(zipFile);

            const response = await github.rest.repos.uploadReleaseAsset({
              url: uploadUrl,
              headers: {
                'content-type': 'application/zip',
                'content-length': data.length
              },
              name: path.basename(zipFile),
              data: data
            });

            console.log('âœ… ZIP uploadÃ©:', response.data.browser_download_url);

          } catch (error) {
            console.error('âŒ Erreur upload ZIP:', error);
            throw error;
          }

    - name: ðŸŽ‰ Confirmation Finale
      shell: pwsh
      run: |
        Write-Host ""
        Write-Host "ðŸŽ‰ðŸŽ‰ðŸŽ‰ BUILD PRIVÃ‰ CRÃ‰Ã‰ AVEC SUCCÃˆS! ðŸŽ‰ðŸŽ‰ðŸŽ‰"
        Write-Host ""
        Write-Host "ðŸ“¦ Version: ${{ steps.version.outputs.version }}"
        Write-Host "ðŸ“ Fichier: ${{ env.ZIP_FILE }}"
        Write-Host "ðŸ”— Release: ${{ steps.create_release.outputs.html_url }}"
        Write-Host ""
        Write-Host "âœ… PRÃŠT Ã€ UTILISER:"
        Write-Host "   1. TÃ©lÃ©chargez le ZIP depuis GitHub"
        Write-Host "   2. Extrayez et lancez ${{ env.APP_NAME }}.exe"
        Write-Host "   3. Autorisez Google Drive"
        Write-Host "   4. Enjoy! ðŸš€"
        Write-Host ""
        Write-Host "ðŸ” Build privÃ© avec VOS credentials inclus"
        Write-Host "âš ï¸  Ne partagez pas ce ZIP (contient vos clÃ©s privÃ©es)"

  upload-to-gdrive:
    name: ðŸ“¤ Upload vers Google Drive
    runs-on: ubuntu-latest
    needs: private-build

    steps:
    - name: ðŸ“¥ Checkout du code
      uses: actions/checkout@v4

    - name: ðŸ Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'

    - name: ðŸ·ï¸ DÃ©terminer la version
      id: version
      run: |
        if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          VERSION="${{ github.event.inputs.version }}"
        else
          VERSION="${{ github.ref_name }}"
        fi

        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "ðŸ“¦ Version Ã  uploader: $VERSION"

    - name: ðŸ“¥ TÃ©lÃ©charger les assets de la release
      uses: actions/github-script@v7
      id: download_assets
      with:
        script: |
          const { owner, repo } = context.repo;
          const fs = require('fs');
          const path = require('path');

          const tag = "${{ steps.version.outputs.version }}";
          console.log(`ðŸ” Recherche des assets pour la release ${tag}...`);

          try {
            // CrÃ©er le dossier downloads
            fs.mkdirSync('downloads', { recursive: true });

            // RÃ©cupÃ©rer les informations de la release
            const release = await github.rest.repos.getReleaseByTag({
              owner,
              repo,
              tag
            });

            console.log(`âœ… Release trouvÃ©e: ${release.data.name}`);

            // Filtrer les assets ZIP
            const zipAssets = release.data.assets.filter(asset => 
              asset.name.endsWith('.zip')
            );

            if (zipAssets.length === 0) {
              console.log('âŒ Aucun fichier ZIP trouvÃ© dans la release');
              return core.setFailed('Aucun fichier ZIP trouvÃ©');
            }

            console.log(`ðŸ“¦ ${zipAssets.length} fichier(s) ZIP trouvÃ©(s)`);

            // TÃ©lÃ©charger chaque asset
            for (const asset of zipAssets) {
              console.log(`â¬‡ï¸ TÃ©lÃ©chargement: ${asset.name}`);

              const response = await github.request({
                method: 'GET',
                url: asset.browser_download_url,
                headers: {
                  accept: 'application/octet-stream'
                },
                responseType: 'arraybuffer'
              });

              const filePath = path.join('downloads', asset.name);
              fs.writeFileSync(filePath, Buffer.from(response.data));

              const stats = fs.statSync(filePath);
              const fileSizeMB = (stats.size / (1024 * 1024)).toFixed(1);

              console.log(`âœ… TÃ©lÃ©chargÃ©: ${asset.name} (${fileSizeMB} MB)`);
            }

            // Sauvegarder les noms des fichiers
            const assetNames = zipAssets.map(asset => asset.name);
            core.setOutput('asset_names', JSON.stringify(assetNames));
            core.setOutput('asset_count', assetNames.length);

            console.log('ðŸ“‹ Assets tÃ©lÃ©chargÃ©s avec succÃ¨s');

          } catch (error) {
            console.error(`âŒ Erreur: ${error.message}`);
            core.setFailed(error.message);
          }

    - name: ðŸ”‘ Setup Service Account Google Drive
      run: |
        echo "ðŸ”‘ Configuration du service account Google Drive..."

        # VÃ©rifier que le secret existe
        if [[ -z "${{ secrets.GOOGLE_DRIVE_SERVICE_ACCOUNT }}" ]]; then
          echo "âŒ ERREUR: Secret GOOGLE_DRIVE_SERVICE_ACCOUNT manquant!"
          echo "ðŸ“ Pour ajouter le secret:"
          echo "   1. Allez dans Settings > Secrets and variables > Actions"
          echo "   2. Cliquez 'New repository secret'"
          echo "   3. Nom: GOOGLE_DRIVE_SERVICE_ACCOUNT"
          echo "   4. Valeur: Collez le contenu JSON de votre service account"
          exit 1
        fi

        # CrÃ©er le fichier service account
        echo '${{ secrets.GOOGLE_DRIVE_SERVICE_ACCOUNT }}' > service-account.json

        # VÃ©rifier que le JSON est valide
        if python -c "import json; json.load(open('service-account.json'))" 2>/dev/null; then
          echo "âœ… Service Account JSON valide"
        else
          echo "âŒ ERREUR: JSON service account invalide"
          exit 1
        fi

        # Afficher l'email du service account (pour debug)
        SERVICE_EMAIL=$(python -c "import json; print(json.load(open('service-account.json'))['client_email'])")
        echo "ðŸ“§ Service Account Email: $SERVICE_EMAIL"
        echo "ðŸ“ Dossier cible ID: ${{ env.GDRIVE_FOLDER_ID }}"

    - name: ðŸ“¦ Installer dÃ©pendances Google Drive
      run: |
        echo "ðŸ“¦ Installation des dÃ©pendances..."
        pip install google-api-python-client google-auth

    - name: ðŸš€ Upload vers Google Drive
      run: |
        echo "ðŸš€ DÃ©marrage de l'upload vers Google Drive..."

        # CrÃ©er le script d'upload Python optimisÃ©
        cat > gdrive_upload.py << 'SCRIPT_EOF'
        import os
        import json
        import glob
        from google.oauth2.service_account import Credentials
        from googleapiclient.discovery import build
        from googleapiclient.http import MediaFileUpload
        from googleapiclient.errors import HttpError

        def main():
            print("ðŸ” Authentification avec Google Drive...")

            try:
                # Configuration
                SERVICE_ACCOUNT_FILE = 'service-account.json'
                SCOPES = ['https://www.googleapis.com/auth/drive']
                TARGET_FOLDER_ID = os.environ.get('GDRIVE_FOLDER_ID')
                VERSION = os.environ.get('VERSION')

                if not TARGET_FOLDER_ID:
                    print("âŒ GDRIVE_FOLDER_ID non dÃ©fini")
                    return False

                # Authentification
                credentials = Credentials.from_service_account_file(
                    SERVICE_ACCOUNT_FILE, scopes=SCOPES
                )
                service = build('drive', 'v3', credentials=credentials)
                print("âœ… Authentification rÃ©ussie")

                # VÃ©rifier l'accÃ¨s au dossier cible
                try:
                    folder_info = service.files().get(
                        fileId=TARGET_FOLDER_ID,
                        fields='id,name,parents'
                    ).execute()
                    print(f"âœ… AccÃ¨s au dossier: {folder_info['name']} (ID: {TARGET_FOLDER_ID})")
                except HttpError as e:
                    print(f"âŒ Impossible d'accÃ©der au dossier {TARGET_FOLDER_ID}: {e}")
                    print("ðŸ” VÃ©rifiez que le dossier est partagÃ© avec le service account")
                    return False

                # Trouver tous les fichiers ZIP Ã  uploader
                zip_files = glob.glob('downloads/*.zip')
                if not zip_files:
                    print("âŒ Aucun fichier ZIP trouvÃ© dans downloads/")
                    return False

                print(f"ðŸ“ {len(zip_files)} fichier(s) Ã  uploader:")
                for zip_file in zip_files:
                    print(f"  - {os.path.basename(zip_file)}")

                uploaded_files = []

                # Uploader chaque fichier
                for zip_file in zip_files:
                    file_name = os.path.basename(zip_file)
                    file_size = os.path.getsize(zip_file) / (1024 * 1024)  # MB

                    print(f"\nâ¬†ï¸ Upload: {file_name} ({file_size:.1f} MB)")

                    # VÃ©rifier si le fichier existe dÃ©jÃ  et le supprimer
                    existing_files = service.files().list(
                        q=f"name='{file_name}' and '{TARGET_FOLDER_ID}' in parents and trashed=false",
                        fields="files(id, name)"
                    ).execute()

                    for existing_file in existing_files.get('files', []):
                        print(f"ðŸ—‘ï¸ Suppression de l'ancienne version: {existing_file['name']}")
                        service.files().delete(fileId=existing_file['id']).execute()

                    # Upload du nouveau fichier
                    file_metadata = {
                        'name': file_name,
                        'parents': [TARGET_FOLDER_ID]
                    }

                    try:
                        media = MediaFileUpload(zip_file, resumable=True)
                        file_result = service.files().create(
                            body=file_metadata,
                            media_body=media,
                            fields='id,name,webViewLink,size'
                        ).execute()

                        # RÃ©sultats
                        file_id = file_result.get('id')
                        web_link = file_result.get('webViewLink')
                        uploaded_size = int(file_result.get('size', 0)) / (1024 * 1024)

                        print(f"âœ… Upload rÃ©ussi!")
                        print(f"   ðŸ“„ Nom: {file_result.get('name')}")
                        print(f"   ðŸ†” ID: {file_id}")
                        print(f"   ðŸ“ Taille: {uploaded_size:.1f} MB")
                        print(f"   ðŸ”— Lien: {web_link}")

                        uploaded_files.append({
                            'name': file_name,
                            'id': file_id,
                            'link': web_link,
                            'size_mb': uploaded_size
                        })

                    except Exception as e:
                        print(f"âŒ Erreur upload {file_name}: {e}")
                        continue

                # Sauvegarder les rÃ©sultats
                if uploaded_files:
                    with open('upload_results.json', 'w') as f:
                        json.dump({
                            'version': VERSION,
                            'folder_id': TARGET_FOLDER_ID,
                            'uploaded_files': uploaded_files,
                            'total_files': len(uploaded_files),
                            'total_size_mb': sum(f['size_mb'] for f in uploaded_files)
                        }, f, indent=2)

                    print(f"\nðŸŽ‰ Upload terminÃ©!")
                    print(f"ðŸ“Š {len(uploaded_files)} fichier(s) uploadÃ©(s)")
                    print(f"ðŸ“ Taille totale: {sum(f['size_mb'] for f in uploaded_files):.1f} MB")
                    return True
                else:
                    print("âŒ Aucun fichier n'a pu Ãªtre uploadÃ©")
                    return False

            except Exception as e:
                print(f"âŒ Erreur gÃ©nÃ©rale: {e}")
                return False

        if __name__ == "__main__":
            success = main()
            exit(0 if success else 1)
        SCRIPT_EOF

        # ExÃ©cuter l'upload
        VERSION="${{ steps.version.outputs.version }}" \
        GDRIVE_FOLDER_ID="${{ env.GDRIVE_FOLDER_ID }}" \
        python gdrive_upload.py

    - name: ðŸ“‹ RÃ©sumÃ© de l'upload
      if: always()
      run: |
        echo "ðŸ“‹ === RÃ‰SUMÃ‰ DE L'UPLOAD ==="
        echo ""

        if [[ -f "upload_results.json" ]]; then
          echo "âœ… Upload rÃ©ussi!"
          echo ""

          VERSION=$(cat upload_results.json | jq -r '.version')
          TOTAL_FILES=$(cat upload_results.json | jq -r '.total_files')
          TOTAL_SIZE=$(cat upload_results.json | jq -r '.total_size_mb')

          echo "ðŸ“¦ Version: $VERSION"
          echo "ðŸ“ Fichiers uploadÃ©s: $TOTAL_FILES"
          echo "ðŸ“ Taille totale: ${TOTAL_SIZE} MB"
          echo "ðŸ“‚ Dossier Google Drive: https://drive.google.com/drive/folders/${{ env.GDRIVE_FOLDER_ID }}"
          echo ""
          echo "ðŸ”— Liens directs:"

          cat upload_results.json | jq -r '.uploaded_files[] | "   ðŸ“„ \(.name): \(.link)"'

        else
          echo "âŒ Upload Ã©chouÃ© ou aucun fichier uploadÃ©"
          echo ""
          echo "ðŸ” VÃ©rifiez:"
          echo "   1. Que la release contient des fichiers ZIP"
          echo "   2. Que le service account a accÃ¨s au dossier"
          echo "   3. Que l'ID du dossier est correct: ${{ env.GDRIVE_FOLDER_ID }}"
        fi
