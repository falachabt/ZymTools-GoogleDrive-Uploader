# ðŸš€ Auto-Release PRIVÃ‰ UNIQUEMENT
name: Auto Release

on:
  push:
    tags:
      - 'v*.*.*'
      - 'test-*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version Ã  releaser (ex: v1.0.0)'
        required: true
        default: 'v1.0.0'

permissions:
  contents: write
  actions: read

env:
  APP_NAME: "ZymoSync"
  PYTHON_VERSION: "3.9"
  # ID du dossier Google Drive cible
  GDRIVE_FOLDER_ID: "1EMQfuyMNHNc3170KXiSbyalx9HbQX5SN"
  PERSONAL_EMAIL: "benny.tenezeu@zymoptiq.com"  #

jobs:
  private-build:
    name: ðŸ”¨ Build PrivÃ© avec Credentials
    runs-on: windows-latest

    steps:
    - name: ðŸ“¥ Checkout du code
      uses: actions/checkout@v4

    - name: ðŸ·ï¸ Extraire la version
      id: version
      shell: bash
      run: |
        if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          VERSION="${{ github.event.inputs.version }}"
        else
          VERSION=${GITHUB_REF#refs/tags/}
        fi

        echo "version=$VERSION" >> $GITHUB_OUTPUT

        CLEAN_VERSION=${VERSION#v}
        echo "clean_version=$CLEAN_VERSION" >> $GITHUB_OUTPUT

        echo "ðŸ“¦ Version: $VERSION"

    - name: ðŸ Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: ðŸ“¦ Installer les dÃ©pendances
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pyinstaller

    # ===== CREDENTIALS PRIVÃ‰S UNIQUEMENT =====
    - name: ðŸ”‘ Setup Credentials PrivÃ©s
      shell: bash
      run: |
        echo "ðŸ” Configuration des credentials privÃ©s..."

        # CrÃ©er le dossier resources
        mkdir -p resources

        # VÃ©rifier que le secret existe (mÃ©thode corrigÃ©e)
        if [ -z "$GOOGLE_CREDENTIALS_JSON" ]; then
          echo "âŒ ERREUR: Secret GOOGLE_CREDENTIALS_JSON manquant!"
          echo "ðŸ“ Pour corriger:"
          echo "   1. Allez dans Settings > Secrets and variables > Actions"
          echo "   2. Cliquez 'New repository secret'"
          echo "   3. Nom: GOOGLE_CREDENTIALS_JSON"
          echo "   4. Valeur: Collez le contenu de votre credentials.json"
          exit 1
        fi

        echo "âœ… Secret trouvÃ©, crÃ©ation du fichier credentials..."

        # Ã‰crire le JSON depuis les secrets (mÃ©thode sÃ©curisÃ©e)
        echo "$GOOGLE_CREDENTIALS_JSON" > resources/credentials.json

        # VÃ©rifier que le JSON est valide
        if python -m json.tool resources/credentials.json > /dev/null 2>&1; then
          echo "âœ… Credentials JSON valide"
        else
          echo "âŒ ERREUR: JSON credentials invalide dans le secret"
          echo "ðŸ” VÃ©rifiez que le secret contient un JSON valide"
          exit 1
        fi

        # VÃ©rifier la prÃ©sence des clÃ©s importantes
        if grep -q "client_id" resources/credentials.json && grep -q "client_secret" resources/credentials.json; then
          echo "âœ… Credentials semblent complets (client_id et client_secret trouvÃ©s)"
        else
          echo "âš ï¸ WARNING: client_id ou client_secret non trouvÃ©s dans les credentials"
        fi

        echo "âœ… Credentials privÃ©s configurÃ©s avec succÃ¨s"
      env:
        GOOGLE_CREDENTIALS_JSON: ${{ secrets.GOOGLE_CREDENTIALS_JSON }}

    - name: ðŸ§¹ Nettoyer les anciens builds
      shell: pwsh
      run: |
        Write-Host "ðŸ§¹ Nettoyage des anciens builds..."
        
        try {
          if (Test-Path "build") { 
            Remove-Item -Recurse -Force "build" 
            Write-Host "âœ… Dossier 'build' supprimÃ©"
          }
          
          if (Test-Path "dist") { 
            Remove-Item -Recurse -Force "dist" 
            Write-Host "âœ… Dossier 'dist' supprimÃ©"
          }
          
          $specFiles = Get-ChildItem -Filter "*.spec" -ErrorAction SilentlyContinue
          if ($specFiles) {
            $specFiles | Remove-Item -Force
            Write-Host "âœ… Fichiers .spec supprimÃ©s"
          }
          
          Write-Host "âœ… Nettoyage terminÃ© avec succÃ¨s"
        } catch {
          Write-Host "âš ï¸ Erreur lors du nettoyage: $($_.Exception.Message)"
          Write-Host "ðŸ”„ Continuation du processus..."
        }

    - name: ðŸ”¨ Build avec PyInstaller
      shell: pwsh
      run: |
        $AppName = "${{ env.APP_NAME }}"
        Write-Host "ðŸš€ Build privÃ© en cours pour $AppName..."

        try {
          $pyinstallerArgs = @(
            "--onedir",
            "--windowed",
            "--icon=resources/icon.ico",
            "--hidden-import=googleapiclient.discovery",
            "--hidden-import=googleapiclient.http",
            "--hidden-import=google.auth.transport.requests",
            "--hidden-import=google.oauth2.credentials",
            "--hidden-import=charset_normalizer.md__mypyc",
            "--hidden-import=sip",
            "--collect-all", "PyQt5",
            "--add-data", "resources;resources",
            "--name", $AppName,
            "main.py"
          )

          Write-Host "ðŸ“‹ Commande PyInstaller:"
          Write-Host "pyinstaller $($pyinstallerArgs -join ' ')"
          
          & pyinstaller @pyinstallerArgs
          
          if ($LASTEXITCODE -eq 0) {
            Write-Host "âœ… Build terminÃ© avec succÃ¨s"
          } else {
            Write-Host "âŒ Build Ã©chouÃ© avec code: $LASTEXITCODE"
            exit 1
          }
        } catch {
          Write-Host "âŒ Erreur lors du build: $($_.Exception.Message)"
          exit 1
        }

    - name: âœ… VÃ©rifier le build
      shell: pwsh
      run: |
        $exePath = "dist\${{ env.APP_NAME }}\${{ env.APP_NAME }}.exe"
        $credPath = "dist\${{ env.APP_NAME }}\resources\credentials.json"

        if (Test-Path $exePath) {
          Write-Host "âœ… ExÃ©cutable crÃ©Ã©: $exePath"
          $size = (Get-Item $exePath).Length / 1MB
          Write-Host "ðŸ“ Taille exe: $([math]::Round($size, 1)) MB"
        } else {
          Write-Host "âŒ ExÃ©cutable non trouvÃ©!"
          Write-Host "ðŸ“ Contenu de dist:"
          Get-ChildItem -Path "dist" -Recurse
          exit 1
        }

        if (Test-Path $credPath) {
          Write-Host "âœ… Credentials inclus dans le build"
        } else {
          Write-Host "âŒ WARNING: credentials.json non trouvÃ© dans le build"
          Write-Host "ðŸ” Recherche dans resources:"
          Get-ChildItem -Path "dist\${{ env.APP_NAME }}" -Recurse -Filter "credentials.json"
        }

        # Afficher la structure du build
        Write-Host "ðŸ“ Structure du build final:"
        Get-ChildItem -Path "dist\${{ env.APP_NAME }}" | Select-Object Name, Length | Format-Table

    - name: ðŸ“¦ CrÃ©er ZIP prÃªt Ã  utiliser
      shell: pwsh
      run: |
        $VERSION = "${{ steps.version.outputs.clean_version }}"
        $AppName = "${{ env.APP_NAME }}"
        $ZIP_NAME = "$AppName-v$VERSION-Windows-READY"
        $ZIP_FILE = "$ZIP_NAME.zip"

        Write-Host "ðŸ“¦ CrÃ©ation du ZIP prÃªt Ã  utiliser..."
        Write-Host "ðŸ“¦ Version: $VERSION"
        Write-Host "ðŸ“¦ Nom APP: $AppName"
        Write-Host "ðŸ“¦ Nom ZIP: $ZIP_FILE"

        # VÃ©rifier que le dossier de build existe
        $buildPath = "dist\$AppName"
        if (-not (Test-Path $buildPath)) {
          Write-Host "âŒ Erreur: Dossier de build non trouvÃ©: $buildPath"
          exit 1
        }

        # CrÃ©er un README pour le ZIP
        $readmeContent = @"
        # ðŸš€ $AppName v$VERSION - PRÃŠT Ã€ UTILISER
        
        ## âœ… Installation ImmÃ©diate
        
        1. **Extraire** ce ZIP dans un dossier de votre choix
        2. **Lancer** $AppName.exe
        3. **Autoriser** l'accÃ¨s Google Drive au premier lancement
        4. **C'est tout !** L'application est prÃªte Ã  utiliser
        
        ## ðŸ”‘ Credentials Inclus
        
        Cette version inclut vos credentials Google Drive API personnels.
        Aucune configuration supplÃ©mentaire n'est nÃ©cessaire.
        
        ## ðŸ†˜ Support
        
        - Documentation: https://github.com/${{ github.repository }}
        - Issues: https://github.com/${{ github.repository }}/issues
        
        ---
        Build privÃ© gÃ©nÃ©rÃ© automatiquement le $(Get-Date -Format "yyyy-MM-dd HH:mm")
        "@

        $readmeContent | Out-File -FilePath "$buildPath\README.txt" -Encoding UTF8
        Write-Host "âœ… README crÃ©Ã©"

        # CrÃ©er le ZIP
        try {
          Compress-Archive -Path "$buildPath\*" -DestinationPath $ZIP_FILE -Force
          Write-Host "âœ… Compression terminÃ©e"
        } catch {
          Write-Host "âŒ Erreur lors de la compression: $($_.Exception.Message)"
          exit 1
        }

        if (Test-Path $ZIP_FILE) {
          $zipSize = (Get-Item $ZIP_FILE).Length / 1MB
          Write-Host "âœ… ZIP crÃ©Ã©: $ZIP_FILE"
          Write-Host "ðŸ“ Taille ZIP: $([math]::Round($zipSize, 1)) MB"
        } else {
          Write-Host "âŒ Erreur: ZIP non crÃ©Ã©"
          exit 1
        }

        # Exporter les variables pour les Ã©tapes suivantes
        "ZIP_FILE=$ZIP_FILE" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
        "ZIP_NAME=$ZIP_NAME" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8

    - name: ðŸ“ GÃ©nÃ©rer changelog
      id: changelog
      shell: bash
      run: |
        VERSION="${{ steps.version.outputs.version }}"

        # CrÃ©er le changelog dans un fichier temporaire pour Ã©viter les problÃ¨mes d'Ã©chappement
        cat > changelog.md << 'EOF'
        ## ðŸš€ ZymoSync $VERSION - Build PrivÃ©

        ðŸ“… **Date**: $(date '+%Y-%m-%d %H:%M:%S')
        ðŸ” **Type**: Build privÃ© avec credentials intÃ©grÃ©s

        ### âœ… PrÃªt Ã  Utiliser ImmÃ©diatement

        Cette version inclut vos credentials Google Drive API personnels.
        Aucune configuration supplÃ©mentaire n'est requise!

        ### ðŸš€ Installation Ultra-Simple

        1. **TÃ©lÃ©chargez** le ZIP ci-dessous
        2. **Extrayez** dans un dossier de votre choix
        3. **Double-cliquez** sur ZymoSync.exe
        4. **Autorisez** Google Drive au premier lancement
        5. **Enjoy!** ðŸŽ‰

        ### ðŸ“¦ DÃ©tails Techniques

        - **Plateforme**: Windows x64
        - **Python**: 3.9
        - **PyQt5**: Inclus
        - **Credentials**: IntÃ©grÃ©s (prÃªt Ã  utiliser)

        ### ðŸ”’ SÃ©curitÃ©

        Ce build privÃ© contient vos credentials personnels Google Drive.
        Ne partagez pas ce fichier avec d'autres personnes.

        ---

        ðŸ’¡ **Besoin d'aide?** Consultez le README.txt inclus dans le ZIP!
        EOF

        # Remplacer la variable VERSION dans le fichier
        sed -i "s/\$VERSION/$VERSION/g" changelog.md

        # Lire le contenu et l'encoder en base64 pour Ã©viter les problÃ¨mes d'Ã©chappement
        CHANGELOG_B64=$(base64 -w 0 changelog.md)
        echo "changelog_b64=$CHANGELOG_B64" >> $GITHUB_OUTPUT

    - name: ðŸŽ‰ CrÃ©er Release PrivÃ©e
      id: create_release
      uses: actions/github-script@v7
      with:
        script: |
          const { owner, repo } = context.repo;
          const tag = "${{ steps.version.outputs.version }}";
          const name = `ðŸ” ZymoSync ${tag} (PrivÃ©)`;

          // DÃ©coder le changelog depuis base64
          const changelogB64 = "${{ steps.changelog.outputs.changelog_b64 }}";
          const body = Buffer.from(changelogB64, 'base64').toString('utf8');

          console.log('ðŸŽ¯ CrÃ©ation de la release privÃ©e...');
          console.log('Tag:', tag);
          console.log('Nom:', name);

          try {
            const release = await github.rest.repos.createRelease({
              owner,
              repo,
              tag_name: tag,
              name: name,
              body: body,
              draft: false,
              prerelease: false
            });

            console.log('âœ… Release crÃ©Ã©e:', release.data.html_url);

            core.setOutput('release_id', release.data.id);
            core.setOutput('upload_url', release.data.upload_url);
            core.setOutput('html_url', release.data.html_url);

          } catch (error) {
            console.error('âŒ Erreur crÃ©ation release:', error);
            throw error;
          }

    - name: ðŸ“Ž Upload ZIP vers Release
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          const path = require('path');

          const zipFile = '${{ env.ZIP_FILE }}';
          const uploadUrl = '${{ steps.create_release.outputs.upload_url }}';

          console.log('ðŸ“Ž Upload du ZIP privÃ©:', zipFile);

          try {
            const data = fs.readFileSync(zipFile);

            const response = await github.rest.repos.uploadReleaseAsset({
              url: uploadUrl,
              headers: {
                'content-type': 'application/zip',
                'content-length': data.length
              },
              name: path.basename(zipFile),
              data: data
            });

            console.log('âœ… ZIP uploadÃ©:', response.data.browser_download_url);

          } catch (error) {
            console.error('âŒ Erreur upload ZIP:', error);
            throw error;
          }

    - name: ðŸŽ‰ Confirmation Finale
      shell: pwsh
      run: |
        $AppName = "${{ env.APP_NAME }}"
        $Version = "${{ steps.version.outputs.version }}"
        $ZipFile = "${{ env.ZIP_FILE }}"
        $ReleaseUrl = "${{ steps.create_release.outputs.html_url }}"
        
        Write-Host ""
        Write-Host "ðŸŽ‰ðŸŽ‰ðŸŽ‰ BUILD PRIVÃ‰ CRÃ‰Ã‰ AVEC SUCCÃˆS! ðŸŽ‰ðŸŽ‰ðŸŽ‰"
        Write-Host ""
        Write-Host "ðŸ“¦ Version: $Version"
        Write-Host "ðŸ“ Fichier: $ZipFile"
        Write-Host "ðŸ”— Release: $ReleaseUrl"
        Write-Host ""
        Write-Host "âœ… PRÃŠT Ã€ UTILISER:"
        Write-Host "   1. TÃ©lÃ©chargez le ZIP depuis GitHub"
        Write-Host "   2. Extrayez et lancez $AppName.exe"
        Write-Host "   3. Autorisez Google Drive"
        Write-Host "   4. Enjoy! ðŸš€"
        Write-Host ""
        Write-Host "ðŸ” Build privÃ© avec VOS credentials inclus"
        Write-Host "âš ï¸  Ne partagez pas ce ZIP (contient vos clÃ©s privÃ©es)"

  upload-to-gdrive:
    name: ðŸ“¤ Upload vers Google Drive
    runs-on: ubuntu-latest
    needs: private-build
    # Ne s'exÃ©cute que si le build prÃ©cÃ©dent a rÃ©ussi
    if: needs.private-build.result == 'success'

    steps:
    - name: ðŸ“¥ Checkout du code
      uses: actions/checkout@v4

    - name: ðŸ Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'

    - name: ðŸ·ï¸ DÃ©terminer la version
      id: version
      run: |
        if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          VERSION="${{ github.event.inputs.version }}"
        else
          VERSION="${{ github.ref_name }}"
        fi

        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "ðŸ“¦ Version Ã  uploader: $VERSION"

    - name: ðŸ“¥ TÃ©lÃ©charger les assets de la release
      uses: actions/github-script@v7
      id: download_assets
      with:
        script: |
          const { owner, repo } = context.repo;
          const fs = require('fs');
          const path = require('path');

          const tag = "${{ steps.version.outputs.version }}";
          console.log(`ðŸ” Recherche des assets pour la release ${tag}...`);

          try {
            // CrÃ©er le dossier downloads
            fs.mkdirSync('downloads', { recursive: true });

            // RÃ©cupÃ©rer les informations de la release
            const release = await github.rest.repos.getReleaseByTag({
              owner,
              repo,
              tag
            });

            console.log(`âœ… Release trouvÃ©e: ${release.data.name}`);

            // Filtrer les assets ZIP
            const zipAssets = release.data.assets.filter(asset => 
              asset.name.endsWith('.zip')
            );

            if (zipAssets.length === 0) {
              console.log('âŒ Aucun fichier ZIP trouvÃ© dans la release');
              return core.setFailed('Aucun fichier ZIP trouvÃ©');
            }

            console.log(`ðŸ“¦ ${zipAssets.length} fichier(s) ZIP trouvÃ©(s)`);

            // TÃ©lÃ©charger chaque asset
            for (const asset of zipAssets) {
              console.log(`â¬‡ï¸ TÃ©lÃ©chargement: ${asset.name}`);

              const response = await github.request({
                method: 'GET',
                url: asset.browser_download_url,
                headers: {
                  accept: 'application/octet-stream'
                },
                responseType: 'arraybuffer'
              });

              const filePath = path.join('downloads', asset.name);
              fs.writeFileSync(filePath, Buffer.from(response.data));

              const stats = fs.statSync(filePath);
              const fileSizeMB = (stats.size / (1024 * 1024)).toFixed(1);

              console.log(`âœ… TÃ©lÃ©chargÃ©: ${asset.name} (${fileSizeMB} MB)`);
            }

            // Sauvegarder les noms des fichiers
            const assetNames = zipAssets.map(asset => asset.name);
            core.setOutput('asset_names', JSON.stringify(assetNames));
            core.setOutput('asset_count', assetNames.length);

            console.log('ðŸ“‹ Assets tÃ©lÃ©chargÃ©s avec succÃ¨s');

          } catch (error) {
            console.error(`âŒ Erreur: ${error.message}`);
            core.setFailed(error.message);
          }

    - name: ðŸ”‘ Setup Service Account Google Drive
      run: |
        echo "ðŸ”‘ Configuration du service account Google Drive..."

        # VÃ©rifier que le secret existe (mÃ©thode corrigÃ©e)
        if [ -z "$GOOGLE_DRIVE_SERVICE_ACCOUNT" ]; then
          echo "âŒ ERREUR: Secret GOOGLE_DRIVE_SERVICE_ACCOUNT manquant!"
          echo "ðŸ“ Pour ajouter le secret:"
          echo "   1. Allez dans Settings > Secrets and variables > Actions"
          echo "   2. Cliquez 'New repository secret'"
          echo "   3. Nom: GOOGLE_DRIVE_SERVICE_ACCOUNT"
          echo "   4. Valeur: Collez le contenu JSON de votre service account"
          exit 1
        fi

        # CrÃ©er le fichier service account
        echo "$GOOGLE_DRIVE_SERVICE_ACCOUNT" > service-account.json

        # VÃ©rifier que le JSON est valide
        if python -c "import json; json.load(open('service-account.json'))" 2>/dev/null; then
          echo "âœ… Service Account JSON valide"
        else
          echo "âŒ ERREUR: JSON service account invalide"
          exit 1
        fi

        # Afficher l'email du service account (pour debug)
        SERVICE_EMAIL=$(python -c "import json; print(json.load(open('service-account.json'))['client_email'])")
        echo "ðŸ“§ Service Account Email: $SERVICE_EMAIL"
        echo "ðŸ“ Dossier cible ID: ${{ env.GDRIVE_FOLDER_ID }}"
        echo "ðŸ“§ Partage avec: ${{ env.PERSONAL_EMAIL }}"
      env:
        GOOGLE_DRIVE_SERVICE_ACCOUNT: ${{ secrets.GOOGLE_DRIVE_SERVICE_ACCOUNT }}

    - name: ðŸ“¦ Installer dÃ©pendances Google Drive
      run: |
        echo "ðŸ“¦ Installation des dÃ©pendances..."
        pip install google-api-python-client google-auth

    - name: ðŸš€ Upload vers Google Drive (avec partage automatique)
      run: |
        echo "ðŸš€ DÃ©marrage de l'upload vers Google Drive avec partage automatique..."

        # Script Python complet avec partage automatique
        cat > gdrive_upload.py << 'SCRIPT_EOF'
        import os
        import json
        import glob
        from google.oauth2.service_account import Credentials
        from googleapiclient.discovery import build
        from googleapiclient.http import MediaFileUpload
        from googleapiclient.errors import HttpError

        def find_folder_by_name(service, folder_name, parent_folder_id=None):
            """Trouve un dossier par nom dans un dossier parent (ou racine si None)"""
            try:
                query = f"name='{folder_name}' and mimeType='application/vnd.google-apps.folder' and trashed=false"
                if parent_folder_id:
                    query += f" and '{parent_folder_id}' in parents"
                
                results = service.files().list(q=query, fields="files(id, name, parents)").execute()
                folders = results.get('files', [])
                
                if folders:
                    print(f"âœ… Dossier trouvÃ©: {folders[0]['name']} (ID: {folders[0]['id']})")
                    return folders[0]['id']
                else:
                    print(f"âŒ Dossier '{folder_name}' non trouvÃ©" + (f" dans {parent_folder_id}" if parent_folder_id else " Ã  la racine"))
                    return None
                    
            except HttpError as e:
                print(f"âŒ Erreur lors de la recherche du dossier '{folder_name}': {e}")
                return None

        def create_folder_in_parent(service, folder_name, parent_folder_id):
            """CrÃ©e un dossier dans un dossier parent"""
            try:
                folder_metadata = {
                    'name': folder_name,
                    'mimeType': 'application/vnd.google-apps.folder',
                    'parents': [parent_folder_id] if parent_folder_id else []
                }
                
                folder = service.files().create(body=folder_metadata, fields='id,name').execute()
                print(f"âœ… Dossier crÃ©Ã©: {folder['name']} (ID: {folder['id']})")
                return folder['id']
                
            except HttpError as e:
                print(f"âŒ Erreur lors de la crÃ©ation du dossier '{folder_name}': {e}")
                return None

        def share_file_with_email(service, file_id, email, file_name):
            """Partage un fichier avec une adresse email spÃ©cifique"""
            if not email or email == 'votre.email@gmail.com':
                print(f"âš ï¸ Email par dÃ©faut dÃ©tectÃ© pour {file_name} - partage ignorÃ©")
                print("ðŸ”§ Changez PERSONAL_EMAIL dans le workflow pour activer le partage automatique")
                return False
                
            try:
                print(f"ðŸ“§ Partage de {file_name} avec {email}...")
                
                permission = {
                    'type': 'user',
                    'role': 'reader',
                    'emailAddress': email
                }
                
                service.permissions().create(
                    fileId=file_id,
                    body=permission,
                    sendNotificationEmail=True
                ).execute()
                
                print(f"âœ… Fichier {file_name} partagÃ© avec {email}")
                return True
                
            except HttpError as e:
                print(f"âš ï¸ Impossible de partager {file_name} avec {email}: {e}")
                return False

        def make_file_public(service, file_id, file_name):
            """Rend un fichier accessible publiquement (lecture seule)"""
            try:
                print(f"ðŸŒ Rendu public: {file_name}...")
                
                permission = {
                    'type': 'anyone',
                    'role': 'reader'
                }
                
                service.permissions().create(
                    fileId=file_id,
                    body=permission
                ).execute()
                
                print(f"âœ… Fichier {file_name} rendu public")
                return True
                
            except HttpError as e:
                print(f"âš ï¸ Impossible de rendre public {file_name}: {e}")
                return False

        def get_target_folder(service, target_folder_id=None):
            """StratÃ©gie intelligente pour trouver ou crÃ©er le dossier cible"""
            
            # StratÃ©gie 1: Essayer d'accÃ©der directement au dossier spÃ©cifiÃ©
            if target_folder_id:
                try:
                    folder_info = service.files().get(
                        fileId=target_folder_id,
                        fields='id,name,parents'
                    ).execute()
                    print(f"âœ… AccÃ¨s direct au dossier: {folder_info['name']} (ID: {target_folder_id})")
                    return target_folder_id
                except HttpError as e:
                    print(f"âš ï¸ Pas d'accÃ¨s direct au dossier {target_folder_id}: {e}")
            
            # StratÃ©gie 2: Chercher le dossier ZymoSync puis le sous-dossier beta
            print("ðŸ” Recherche du dossier ZymoSync...")
            zymosync_folder_id = find_folder_by_name(service, "ZymoSync")
            
            if zymosync_folder_id:
                print("ðŸ” Recherche du dossier beta dans ZymoSync...")
                beta_folder_id = find_folder_by_name(service, "beta", zymosync_folder_id)
                
                if beta_folder_id:
                    return beta_folder_id
                else:
                    print("ðŸ“ CrÃ©ation du dossier beta dans ZymoSync...")
                    return create_folder_in_parent(service, "beta", zymosync_folder_id)
            
            # StratÃ©gie 3: Chercher tous les dossiers "beta" accessibles
            print("ðŸ” Recherche de tous les dossiers 'beta' accessibles...")
            all_beta_folders = find_folder_by_name(service, "beta")
            if all_beta_folders:
                return all_beta_folders
            
            # StratÃ©gie 4: CrÃ©er un nouveau dossier ZymoSync Ã  la racine
            print("ðŸ“ CrÃ©ation d'un nouveau dossier ZymoSync...")
            new_zymosync_id = create_folder_in_parent(service, "ZymoSync-Releases", None)
            if new_zymosync_id:
                return create_folder_in_parent(service, "beta", new_zymosync_id)
            
            return None

        def main():
            print("ðŸ” Authentification avec Google Drive...")

            try:
                # Configuration
                SERVICE_ACCOUNT_FILE = 'service-account.json'
                SCOPES = ['https://www.googleapis.com/auth/drive']
                TARGET_FOLDER_ID = os.environ.get('GDRIVE_FOLDER_ID')
                VERSION = os.environ.get('VERSION', 'unknown')
                PERSONAL_EMAIL = os.environ.get('PERSONAL_EMAIL', '')
                
                # Authentification
                credentials = Credentials.from_service_account_file(
                    SERVICE_ACCOUNT_FILE, scopes=SCOPES
                )
                service = build('drive', 'v3', credentials=credentials)
                print("âœ… Authentification rÃ©ussie")

                # Afficher l'email du service account pour debug
                with open(SERVICE_ACCOUNT_FILE, 'r') as f:
                    service_data = json.load(f)
                    service_email = service_data.get('client_email', 'Unknown')
                print(f"ðŸ“§ Service Account: {service_email}")
                print(f"ðŸ“§ Partage automatique avec: {PERSONAL_EMAIL}")

                # Trouver le dossier cible avec stratÃ©gie intelligente
                print(f"\nðŸŽ¯ Recherche du dossier cible (ID souhaitÃ©: {TARGET_FOLDER_ID})...")
                folder_id = get_target_folder(service, TARGET_FOLDER_ID)
                
                if not folder_id:
                    print("âŒ Impossible de trouver ou crÃ©er un dossier cible")
                    return False
                    
                print(f"ðŸ“ Dossier cible final: ID = {folder_id}")
                print(f"ðŸ”— Lien: https://drive.google.com/drive/folders/{folder_id}")

                # Trouver tous les fichiers ZIP Ã  uploader
                zip_files = glob.glob('downloads/*.zip')
                if not zip_files:
                    print("âŒ Aucun fichier ZIP trouvÃ© dans downloads/")
                    return False

                print(f"\nðŸ“ {len(zip_files)} fichier(s) Ã  uploader:")
                for zip_file in zip_files:
                    file_size = os.path.getsize(zip_file) / (1024 * 1024)
                    print(f"  - {os.path.basename(zip_file)} ({file_size:.1f} MB)")

                uploaded_files = []

                # Uploader chaque fichier
                for zip_file in zip_files:
                    file_name = os.path.basename(zip_file)
                    file_size = os.path.getsize(zip_file) / (1024 * 1024)  # MB

                    print(f"\nâ¬†ï¸ Upload: {file_name} ({file_size:.1f} MB)")

                    # VÃ©rifier si le fichier existe dÃ©jÃ  et le supprimer
                    existing_files = service.files().list(
                        q=f"name='{file_name}' and '{folder_id}' in parents and trashed=false",
                        fields="files(id, name)"
                    ).execute()

                    for existing_file in existing_files.get('files', []):
                        print(f"ðŸ—‘ï¸ Suppression de l'ancienne version: {existing_file['name']}")
                        service.files().delete(fileId=existing_file['id']).execute()

                    # Upload du nouveau fichier
                    file_metadata = {
                        'name': file_name,
                        'parents': [folder_id]
                    }

                    try:
                        media = MediaFileUpload(zip_file, resumable=True)
                        file_result = service.files().create(
                            body=file_metadata,
                            media_body=media,
                            fields='id,name,webViewLink,size'
                        ).execute()

                        # RÃ©sultats
                        file_id = file_result.get('id')
                        web_link = file_result.get('webViewLink')
                        uploaded_size = int(file_result.get('size', 0)) / (1024 * 1024)

                        print(f"âœ… Upload rÃ©ussi!")
                        print(f"   ðŸ“„ Nom: {file_result.get('name')}")
                        print(f"   ðŸ†” ID: {file_id}")
                        print(f"   ðŸ“ Taille: {uploaded_size:.1f} MB")
                        print(f"   ðŸ”— Lien: {web_link}")

                        # ðŸŽ¯ PARTAGE AUTOMATIQUE
                        print(f"\nðŸ“§ === PARTAGE AUTOMATIQUE ===")
                        
                        # Partager avec l'email personnel si fourni
                        if PERSONAL_EMAIL and PERSONAL_EMAIL != 'votre.email@gmail.com':
                            share_success = share_file_with_email(service, file_id, PERSONAL_EMAIL, file_name)
                            if share_success:
                                print(f"âœ… Notification envoyÃ©e Ã  {PERSONAL_EMAIL}")
                        else:
                            print("âš ï¸ Email personnel non configurÃ© - partage spÃ©cifique ignorÃ©")
                        
                        # Option: Rendre le fichier public (dÃ©commentez si souhaitÃ©)
                        # make_file_public(service, file_id, file_name)
                        
                        uploaded_files.append({
                            'name': file_name,
                            'id': file_id,
                            'link': web_link,
                            'size_mb': uploaded_size,
                            'shared_with': PERSONAL_EMAIL if PERSONAL_EMAIL != 'votre.email@gmail.com' else None
                        })

                    except Exception as e:
                        print(f"âŒ Erreur upload {file_name}: {e}")
                        continue

                # Sauvegarder les rÃ©sultats
                if uploaded_files:
                    with open('upload_results.json', 'w') as f:
                        json.dump({
                            'version': VERSION,
                            'folder_id': folder_id,
                            'folder_link': f"https://drive.google.com/drive/folders/{folder_id}",
                            'uploaded_files': uploaded_files,
                            'total_files': len(uploaded_files),
                            'total_size_mb': sum(f['size_mb'] for f in uploaded_files),
                            'shared_with': PERSONAL_EMAIL if PERSONAL_EMAIL != 'votre.email@gmail.com' else None
                        }, f, indent=2)

                    print(f"\nðŸŽ‰ Upload terminÃ©!")
                    print(f"ðŸ“Š {len(uploaded_files)} fichier(s) uploadÃ©(s)")
                    print(f"ðŸ“ Taille totale: {sum(f['size_mb'] for f in uploaded_files):.1f} MB")
                    print(f"ðŸ“ Dossier final: https://drive.google.com/drive/folders/{folder_id}")
                    
                    if PERSONAL_EMAIL and PERSONAL_EMAIL != 'votre.email@gmail.com':
                        print(f"ðŸ“§ Notifications envoyÃ©es Ã : {PERSONAL_EMAIL}")
                        print(f"âœ… Vous devriez recevoir un email de partage Google Drive")
                    
                    return True
                else:
                    print("âŒ Aucun fichier n'a pu Ãªtre uploadÃ©")
                    return False

            except Exception as e:
                print(f"âŒ Erreur gÃ©nÃ©rale: {e}")
                return False

        if __name__ == "__main__":
            success = main()
            exit(0 if success else 1)
        SCRIPT_EOF

        # ExÃ©cuter l'upload avec le script amÃ©liorÃ©
        VERSION="${{ steps.version.outputs.version }}" \
        GDRIVE_FOLDER_ID="${{ env.GDRIVE_FOLDER_ID }}" \
        PERSONAL_EMAIL="${{ env.PERSONAL_EMAIL }}" \
        python gdrive_upload.py

    - name: ðŸ“‹ RÃ©sumÃ© de l'upload
      if: always()
      run: |
        echo "ðŸ“‹ === RÃ‰SUMÃ‰ DE L'UPLOAD ==="
        echo ""

        if [[ -f "upload_results.json" ]]; then
          echo "âœ… Upload rÃ©ussi!"
          echo ""

          VERSION=$(cat upload_results.json | jq -r '.version')
          TOTAL_FILES=$(cat upload_results.json | jq -r '.total_files')
          TOTAL_SIZE=$(cat upload_results.json | jq -r '.total_size_mb')
          SHARED_WITH=$(cat upload_results.json | jq -r '.shared_with // "Non configurÃ©"')

          echo "ðŸ“¦ Version: $VERSION"
          echo "ðŸ“ Fichiers uploadÃ©s: $TOTAL_FILES"
          echo "ðŸ“ Taille totale: ${TOTAL_SIZE} MB"
          echo "ðŸ“§ PartagÃ© avec: $SHARED_WITH"
          echo "ðŸ“‚ Dossier Google Drive: https://drive.google.com/drive/folders/${{ env.GDRIVE_FOLDER_ID }}"
          echo ""
          echo "ðŸ”— Liens directs:"

          cat upload_results.json | jq -r '.uploaded_files[] | "   ðŸ“„ \(.name): \(.link)"'
          
          echo ""
          if [[ "$SHARED_WITH" != "Non configurÃ©" && "$SHARED_WITH" != "null" ]]; then
            echo "ðŸ“§ âœ… Notification de partage envoyÃ©e Ã : $SHARED_WITH"
            echo "ðŸ“¬ VÃ©rifiez votre boÃ®te mail pour la notification Google Drive"
          else
            echo "âš ï¸ Partage automatique non configurÃ©"
            echo "ðŸ”§ Changez PERSONAL_EMAIL dans le workflow pour activer le partage"
          fi

        else
          echo "âŒ Upload Ã©chouÃ© ou aucun fichier uploadÃ©"
          echo ""
          echo "ðŸ” VÃ©rifiez:"
          echo "   1. Que la release contient des fichiers ZIP"
          echo "   2. Que le service account a accÃ¨s au dossier"
          echo "   3. Que l'ID du dossier est correct: ${{ env.GDRIVE_FOLDER_ID }}"
        fi